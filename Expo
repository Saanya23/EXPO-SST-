<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>UAE Expo Pavilions — 3D Animation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Helvetica,Arial; background: linear-gradient(180deg,#f0f9ff,#ffffff); }
    #container { width:100%; height:100vh; position:relative; overflow:hidden; }
    canvas { display:block; } 
    .ui {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 20;
      user-select: none;
    }
    .dot {
      width:14px; height:14px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.9);
      background:transparent; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.2);
    }
    .dot.active { background: white; }
    .controls {
      position:absolute; left:18px; top:18px; z-index:20; display:flex; gap:8px;
    }
    .btn { background:white; padding:8px 12px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.12); cursor:pointer; border:none; font-weight:600; }
    .caption {
      position:absolute; right:18px; top:18px; z-index:20; background: rgba(0,0,0,0.5); color: #fff; padding:10px 14px; border-radius:10px; max-width:320px; font-size:14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.2);
    }
    @media (max-width:720px){
      .caption { display:none; }
      .btn { padding:6px 8px; }
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="controls" role="group" aria-label="Controls">
    <button id="prevBtn" class="btn">◀ Prev</button>
    <button id="nextBtn" class="btn">Next ▶</button>
  </div>

  <div class="caption" id="caption">Loading...</div>

  <div class="ui" id="dots"></div>

  <!-- three.js (r152 as module-free UMD) -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  (function () {
    const container = document.getElementById('container');
    const captionEl = document.getElementById('caption');
    const dotsEl = document.getElementById('dots');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    // --- Pavilion data (real images)
    const pavilions = [
      {
        title: 'Expo 1970 — Osaka (early Emirati participation)',
        year: 1970,
        img: 'https://upload.wikimedia.org/wikipedia/commons/5/5b/Expo_1970_Osaka.jpg',
        text: 'Early participation introduced Emirati crafts and trade to visitors.'
      },
      {
        title: 'Expo 2000 — Hannover (UAE pavilion)',
        year: 2000,
        img: 'https://upload.wikimedia.org/wikipedia/commons/e/e0/Expo_2000_germany_pavilion.jpg',
        text: 'Large national display showing heritage and modern achievements.'
      },
      {
        title: 'Expo 2010 — Shanghai (Dune-inspired pavilion)',
        year: 2010,
        img: 'https://upload.wikimedia.org/wikipedia/commons/9/9d/United_Arab_Emirates_Pavilion_Expo_2010.jpg',
        text: 'Designed by Foster + Partners: gold-reflective dune-like skin and sustainability themes.'
      },
      {
        title: 'Expo 2015 — Milan (shaded streets concept)',
        year: 2015,
        img: 'https://upload.wikimedia.org/wikipedia/commons/7/74/UAE_Pavilion_Expo_2015_Milan.jpg',
        text: 'Evokes compact desert-city planning and passive cooling.'
      },
      {
        title: 'Expo 2017 — Astana (energy focus)',
        year: 2017,
        img: 'https://upload.wikimedia.org/wikipedia/commons/8/84/Astana_Expo_2017_UAE.jpg',
        text: 'Showcased energy diversification, renewables and interactive exhibits.'
      },
      {
        title: 'Expo 2020 — Dubai (Falcon Pavilion)',
        year: 2021,
        img: 'https://upload.wikimedia.org/wikipedia/commons/f/fb/UAE_Pavilion_Expo_2020.jpg',
        text: 'Falcon-in-flight design, movable wings and photovoltaic integration.'
      },
    ];

    // three.js setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0xeaf6ff, 0.02);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2.2, 10);

    const ambient = new THREE.AmbientLight(0xffffff, 0.85);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5, 10, 5);
    scene.add(dir);

    // soft ground plane for subtle shadow/reflection (not physically accurate)
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xf2f9ff, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -2.5;
    scene.add(ground);

    // controls (light)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.autoRotate = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.minPolarAngle = 0.4;
    controls.maxPolarAngle = 1.4;

    // load textures and create panels
    const loader = new THREE.TextureLoader();
    const panels = [];
    const spacing = 6;
    let loaded = 0;

    pavilions.forEach((p, i) => {
      loader.crossOrigin = '';
      loader.load(p.img, (tex) => {
        tex.minFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(5.2, 3.2);
        const material = new THREE.MeshStandardMaterial({ map: tex, side: THREE.FrontSide });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(i * spacing, 0.2, 0);
        mesh.userData = { index: i };
        mesh.castShadow = false;
        mesh.receiveShadow = false;

        // small base panel behind for a thicker look
        const backGeo = new THREE.BoxGeometry(5.25, 3.25, 0.12);
        const backMat = new THREE.MeshStandardMaterial({ color: 0x0b1324, metalness: 0.2, roughness: 0.6 });
        const back = new THREE.Mesh(backGeo, backMat);
        back.position.set(0, 0, -0.06);
        mesh.add(back);

        // subtle float animation values
        mesh.userData.floatOffset = Math.random() * Math.PI * 2;
        mesh.userData.baseY = mesh.position.y;

        scene.add(mesh);
        panels.push(mesh);

        loaded++;
        if (loaded === pavilions.length) {
          // all loaded
          startRendering();
        }
      }, undefined, (err) => {
        console.warn('Image load failed:', p.img, err);
        loaded++;
        if (loaded === pavilions.length) startRendering();
      });
    });

    // UI dots
    let currentIndex = 0;
    function buildDots() {
      dotsEl.innerHTML = '';
      pavilions.forEach((p, i) => {
        const d = document.createElement('div');
        d.className = 'dot' + (i === 0 ? ' active' : '');
        d.title = p.title;
        d.addEventListener('click', () => goToIndex(i));
        dotsEl.appendChild(d);
      });
    }
    buildDots();

    function updateCaption(i) {
      const p = pavilions[i];
      captionEl.innerHTML = '<strong>' + p.title + '</strong><br/><small>' + p.year + '</small><br/>' + p.text;
    }

    // camera animation helpers
    let targetX = 0;
    function goToIndex(i) {
      currentIndex = i;
      targetX = i * spacing;
      // update dots
      Array.from(dotsEl.children).forEach((el, idx) => el.classList.toggle('active', idx === i));
      updateCaption(i);
    }

    prevBtn.addEventListener('click', () => goToIndex((currentIndex - 1 + pavilions.length) % pavilions.length));
    nextBtn.addEventListener('click', () => goToIndex((currentIndex + 1) % pavilions.length));

    // auto-play timeline
    let autoplay = true;
    let autoplayId = null;
    function startAutoplay() {
      stopAutoplay();
      autoplayId = setInterval(() => {
        if (!autoplay) return;
        goToIndex((currentIndex + 1) % pavilions.length);
      }, 5000);
    }
    function stopAutoplay() {
      if (autoplayId) { clearInterval(autoplayId); autoplayId = null; }
    }

    // pause autoplay if user interacts
    [prevBtn, nextBtn, dotsEl, renderer.domElement].forEach(el => {
      el.addEventListener('mouseenter', () => { autoplay = false; });
      el.addEventListener('mouseleave', () => { autoplay = true; });
    });

    // initial caption
    updateCaption(0);
    startAutoplay();

    // animation loop
    let lastTime = 0;
    function animate(time) {
      requestAnimationFrame(animate);
      const dt = (time - lastTime) / 1000 || 0;
      lastTime = time;

      // animate each panel float
      panels.forEach((m, idx) => {
        const t = performance.now() / 1000 + m.userData.floatOffset;
        m.position.y = m.userData.baseY + Math.sin(t * 0.9) * 0.18;
        m.rotation.y = Math.sin(t * 0.6) * 0.08 * (idx % 2 ? 1 : -1);
      });

      // smooth camera x to targetX
      const ease = 0.08;
      camera.position.x += (targetX - camera.position.x) * ease;
      // slight bobbing on camera
      camera.position.y = 2.2 + Math.sin(performance.now() / 1200) * 0.08;
      // keep camera looking at center-line between panels
      const lookAtPoint = new THREE.Vector3((targetX)/2, 0.2, 0);
      camera.lookAt(lookAtPoint);

      // subtle movement for controls
      controls.update();

      renderer.render(scene, camera);
    }

    function startRendering() {
      // set initial targetX to 0
      targetX = 0;
      animate(0);
    }

    // responsive
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') nextBtn.click();
      if (e.key === 'ArrowLeft') prevBtn.click();
    });

    // set initial camera target
    goToIndex(0);

    // helpful note if user wants to replace images
    console.log('To replace images, edit the pavilions[] array in the HTML and set .img to another public image URL.');
  })();
  </script>
</body>
</html>
